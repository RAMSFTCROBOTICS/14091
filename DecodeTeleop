package org.firstinspires.ftc.teamcode;

import com.qualcomm.robotcore.eventloop.opmode.LinearOpMode;
import com.qualcomm.robotcore.hardware.DcMotorEx;
import com.qualcomm.robotcore.eventloop.opmode.TeleOp;
import com.qualcomm.robotcore.hardware.DcMotor;
import com.qualcomm.robotcore.hardware.DcMotorSimple;
import com.qualcomm.robotcore.hardware.IMU;
import com.qualcomm.robotcore.hardware.Servo;
import com.qualcomm.hardware.rev.RevHubOrientationOnRobot;
import com.qualcomm.robotcore.util.ElapsedTime;
import com.qualcomm.robotcore.util.Range; // Import Range for safety
import org.firstinspires.ftc.robotcore.external.navigation.AngleUnit;
import com.qualcomm.hardware.dfrobot.HuskyLens;

@TeleOp(name = "DecodeTeleop", group = "Competition")
public class DecodeTeleop extends LinearOpMode {

    private HuskyLens huskyLens;

    @Override
    public void runOpMode() throws InterruptedException {
        // --- HARDWARE MAPPING ---
        DcMotorEx frontLeftMotor = hardwareMap.get(DcMotorEx.class, "frontLeft");
        DcMotorEx backLeftMotor = hardwareMap.get(DcMotorEx.class, "backLeft");
        DcMotorEx frontRightMotor = hardwareMap.get(DcMotorEx.class, "frontRight");
        DcMotorEx backRightMotor = hardwareMap.get(DcMotorEx.class, "backRight");
        
        DcMotorEx LeftSpinner = hardwareMap.get(DcMotorEx.class, "LeftSpinner");
        DcMotorEx RightSpinner = hardwareMap.get(DcMotorEx.class, "RightSpinner");
        
        Servo BallDrop = hardwareMap.get(Servo.class, "BallDrop");

        huskyLens = hardwareMap.get(HuskyLens.class, "huskylens");

        // --- HUSKYLENS SETUP ---
        // Vital: This only sets the algorithm in code. 
        // You MUST ensure the HuskyLens physical menu is also set correctly!
        if (!huskyLens.knock()) {
            telemetry.addData(">>", "Problem communicating with HuskyLens!");
            telemetry.addData(">>", "Check your connections (I2C vs UART)");
        } else {
            telemetry.addData(">>", "HuskyLens Connection Confirmed");
            huskyLens.selectAlgorithm(HuskyLens.Algorithm.TAG_RECOGNITION);
        }
        
        // --- MOTOR DIRECTION ---
        frontLeftMotor.setDirection(DcMotorSimple.Direction.REVERSE);
        backLeftMotor.setDirection(DcMotorSimple.Direction.REVERSE);
        
        // Set motors to use encoders
        frontLeftMotor.setMode(DcMotor.RunMode.RUN_USING_ENCODER);
        backLeftMotor.setMode(DcMotor.RunMode.RUN_USING_ENCODER);
        frontRightMotor.setMode(DcMotor.RunMode.RUN_USING_ENCODER);
        backRightMotor.setMode(DcMotor.RunMode.RUN_USING_ENCODER);

        // --- IMU INITIALIZATION ---
        IMU imu = hardwareMap.get(IMU.class, "imu");
        IMU.Parameters parameters = new IMU.Parameters(new RevHubOrientationOnRobot(
                RevHubOrientationOnRobot.LogoFacingDirection.UP,
                RevHubOrientationOnRobot.UsbFacingDirection.FORWARD
        ));
        imu.initialize(parameters);
        
        BallDrop.setPosition(.2);
        ElapsedTime ballDropTimer = new ElapsedTime();
        boolean isDropping = false;
        boolean previousYPressed = false;
        double targetHeading = 0; // Target heading for D-pad control

        telemetry.update();
        waitForStart();

        while (opModeIsActive()) {

            // --- GAMEPAD INPUTS ---
            double y = -gamepad1.left_stick_y; 
            double x = gamepad1.left_stick_x;  
            double rx = gamepad1.right_stick_x; 

            // --- AUTO AIM LOGIC ---
            if (gamepad1.left_bumper) {
                
                HuskyLens.Block[] blocks = huskyLens.blocks();
                
                // DEBUG: Tell us exactly what the camera sees
                telemetry.addData("Block Count", blocks.length);

                HuskyLens.Block targetTag = null;
                for (HuskyLens.Block block : blocks) {
                    // Look for ID 4 or ID 1
                    if (block.id == 4 || block.id == 1) {
                        targetTag = block;
                        break;
                    }
                }

                if (targetTag != null) {
                    // Calculate error (Center is 160)
                    double error = targetTag.x - 200;
                    
                    // Increased P-Gain slightly. 
                    // If robot oscillates (shakes), lower this back to 0.005
                    double kP = 0.005; 
                    
                    // Calculate turn power
                    double turnPower = error * kP;
                    
                    // SAFETY: Clip power so it doesn't spin insanely fast
                    // Also useful if kP is high
                    rx = Range.clip(turnPower, -0.2, 0.2);

                    telemetry.addData("Target", "FOUND Tag:ID" + targetTag.id);
                    telemetry.addData("X Position", targetTag.x);
                    telemetry.addData("Calculated rx", rx);
                } else {
                    telemetry.addData("Target", "Searching... (No tag:ID 4 or 1 seen)");
                    // OPTIONAL: Make rx = 0 here if you want to DISABLE manual turning 
                    // while searching. Currently, it allows the driver to turn manually 
                    // if the tag isn't seen.
                }
            }

            // --- HEADING RESET ---
            if (gamepad1.a) {
                imu.resetYaw();
                targetHeading = 0;
            }
            
            // --- HEADING CONTROL (D-PAD) ---
            if (gamepad1.dpad_left) {
                targetHeading = Math.toRadians(45); // Set heading to 45 degrees
                // Calculate rotation needed to reach target heading
                double currentHeading = imu.getRobotYawPitchRollAngles().getYaw(AngleUnit.RADIANS);
                double headingError = targetHeading - currentHeading;
                // Normalize angle to [-PI, PI]
                while (headingError > Math.PI) headingError -= 2 * Math.PI;
                while (headingError < -Math.PI) headingError += 2 * Math.PI;
                rx = Range.clip(headingError * 8.0, -1.0, 1.0); // Increased P-gain to 3.0
            } else if (gamepad1.dpad_right) {
                targetHeading = Math.toRadians(135); // Set heading to 135 degrees
                // Calculate rotation needed to reach target heading
                double currentHeading = imu.getRobotYawPitchRollAngles().getYaw(AngleUnit.RADIANS);
                double headingError = targetHeading - currentHeading;
                // Normalize angle to [-PI, PI]
                while (headingError > Math.PI) headingError -= 2 * Math.PI;
                while (headingError < -Math.PI) headingError += 2 * Math.PI;
                rx = Range.clip(headingError * 8.0, -1.0, 1.0); // Increased P-gain to 3.0
            }

            // --- SPINNERS ---
            if (gamepad2.right_bumper) {
                LeftSpinner.setVelocity(-950);
                RightSpinner.setVelocity(950);
            } else {
                LeftSpinner.setVelocity(0);
                RightSpinner.setVelocity(0);
            }
            
            // --- BALL DROP ---
            // Detect Y button press (not hold)
            boolean yPressed = gamepad2.y;
            if (yPressed && !previousYPressed && !isDropping && Math.abs(RightSpinner.getVelocity()) >= 2550) {
                // Y was just pressed
                isDropping = true;
                ballDropTimer.reset();
                BallDrop.setPosition(0.0); // Open position
                telemetry.addData("ACTION", "Ball Drop OPENED");
            }
            previousYPressed = yPressed;
            
            // Close the ball after 0.2 seconds
            if (isDropping && ballDropTimer.seconds() >= 0.2 && ballDropTimer.seconds() < 0.3) {
                telemetry.addData("ACTION", "Ball Drop CLOSING");
                BallDrop.setPosition(0.2); // Closed position
            }
            
            // End dropping sequence
            if (isDropping && ballDropTimer.seconds() >= 0.3) {
                isDropping = false;
                telemetry.addData("ACTION", "Ball Drop CLOSED");
            }
            
            // Debug telemetry
            telemetry.addData("Y Pressed", gamepad2.y);
            telemetry.addData("Is Dropping", isDropping);
            telemetry.addData("RightSpinner Velocity", Math.abs(RightSpinner.getVelocity()));
            telemetry.addData("Ball Drop Timer", ballDropTimer.seconds());
            telemetry.addData("Ball Drop Position", BallDrop.getPosition());
            telemetry.addData("FrontLeft Velocity", frontLeftMotor.getVelocity());
            telemetry.addData("BackLeft Velocity", backLeftMotor.getVelocity());
            telemetry.addData("FrontRight Velocity", frontRightMotor.getVelocity());
            telemetry.addData("BackRight Velocity", backRightMotor.getVelocity());

            // --- FIELD CENTRIC DRIVE ---
            double botHeading = imu.getRobotYawPitchRollAngles().getYaw(AngleUnit.RADIANS) - targetHeading;
            double rotX = x * Math.cos(-botHeading) - y * Math.sin(-botHeading);
            double rotY = x * Math.sin(-botHeading) + y * Math.cos(-botHeading);

            rotX = rotX * 1.1; 

            double denominator = Math.max(Math.abs(rotY) + Math.abs(rotX) + Math.abs(rx), 1);
            double frontLeftPower = (rotY + rotX + rx) / denominator;
            double backLeftPower = (rotY - rotX + rx) / denominator;
            double frontRightPower = (rotY - rotX - rx) / denominator;
            double backRightPower = (rotY + rotX - rx) / denominator;

            frontLeftMotor.setPower(frontLeftPower);
            backLeftMotor.setPower(backLeftPower);
            frontRightMotor.setPower(frontRightPower);
            backRightMotor.setPower(backRightPower);

            telemetry.update();
        }
    }
}
