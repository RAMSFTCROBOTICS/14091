package org.firstinspires.ftc.teamcode;

import com.qualcomm.robotcore.eventloop.opmode.LinearOpMode;
import com.qualcomm.robotcore.hardware.DcMotorEx;
import com.qualcomm.robotcore.eventloop.opmode.TeleOp;
import com.qualcomm.robotcore.hardware.DcMotor;
import com.qualcomm.robotcore.hardware.DcMotorSimple;
import com.qualcomm.robotcore.hardware.IMU;
import com.qualcomm.robotcore.hardware.Servo;
import com.qualcomm.hardware.rev.RevHubOrientationOnRobot;
import com.qualcomm.robotcore.util.ElapsedTime;
import com.qualcomm.robotcore.util.Range; 
import org.firstinspires.ftc.robotcore.external.navigation.AngleUnit;
import com.qualcomm.hardware.dfrobot.HuskyLens;

@TeleOp(name = "DecodeTeleop", group = "Competition")
public class DecodeTeleop extends LinearOpMode {

    private HuskyLens huskyLens;

    @Override
    public void runOpMode() throws InterruptedException {
        // --- HARDWARE MAPPING ---
        DcMotorEx frontLeftMotor = hardwareMap.get(DcMotorEx.class, "frontLeft");
        DcMotorEx backLeftMotor = hardwareMap.get(DcMotorEx.class, "backLeft");
        DcMotorEx frontRightMotor = hardwareMap.get(DcMotorEx.class, "frontRight");
        DcMotorEx backRightMotor = hardwareMap.get(DcMotorEx.class, "backRight");
        
        DcMotorEx LeftSpinner = hardwareMap.get(DcMotorEx.class, "LeftSpinner");
        DcMotorEx RightSpinner = hardwareMap.get(DcMotorEx.class, "RightSpinner");
        
        Servo BallDrop = hardwareMap.get(Servo.class, "BallDrop");
        huskyLens = hardwareMap.get(HuskyLens.class, "huskylens");
        
        // --- STATE VARIABLES ---
        boolean isAutoTurning = false;
        // --- PID CONTROL VARIABLES ---
double Kp = 0.008;  // Proportional (Start slightly higher than your 0.01)
double Ki = 0.000;    // Integral (Usually very small, like 0.0001)
double Kd = 0.002;  // Derivative (The "brake")

double integralSum = 0;
double lastError = 0;

// --- VISION PID VARIABLES ---
double vKp = 0.002;   // Vision Proportional (Smaller because pixel errors are large numbers)
double vKi = 0.0;     // Vision Integral
double vKd = 0.0002;  // Vision Derivative (The brake)

double vIntegralSum = 0;
double vLastError = 0;
ElapsedTime vPidTimer = new ElapsedTime();
boolean wasLeftBumperPressed = false; // Tracks when you first press the button to reset the math

ElapsedTime pidTimer = new ElapsedTime(); // Tracks time between loops for calculus math
        boolean isDropping = false;
        boolean previousYPressed = false;
        double targetHeading = 0; // Target heading for D-pad control

        // --- HUSKYLENS SETUP ---
        if (!huskyLens.knock()) {
            telemetry.addData(">>", "Problem communicating with HuskyLens!");
            telemetry.addData(">>", "Check your connections (I2C vs UART)");
        } else {
            telemetry.addData(">>", "HuskyLens Connection Confirmed");
            huskyLens.selectAlgorithm(HuskyLens.Algorithm.TAG_RECOGNITION);
        }
        
        // --- MOTOR DIRECTION ---
        frontLeftMotor.setDirection(DcMotorSimple.Direction.REVERSE);
        backLeftMotor.setDirection(DcMotorSimple.Direction.REVERSE);
        LeftSpinner.setDirection(DcMotorSimple.Direction.REVERSE);
        
        
        // Set motors to use encoders
        frontLeftMotor.setMode(DcMotor.RunMode.RUN_USING_ENCODER);
        backLeftMotor.setMode(DcMotor.RunMode.RUN_USING_ENCODER);
        frontRightMotor.setMode(DcMotor.RunMode.RUN_USING_ENCODER);
        backRightMotor.setMode(DcMotor.RunMode.RUN_USING_ENCODER);
        
        // ADD THIS: Turn on the Control Hub's velocity PID for the spinners
LeftSpinner.setMode(DcMotor.RunMode.RUN_USING_ENCODER);
RightSpinner.setMode(DcMotor.RunMode.RUN_USING_ENCODER);

        // --- IMU INITIALIZATION ---
        IMU imu = hardwareMap.get(IMU.class, "imu");
        IMU.Parameters parameters = new IMU.Parameters(new RevHubOrientationOnRobot(
                RevHubOrientationOnRobot.LogoFacingDirection.UP,
                RevHubOrientationOnRobot.UsbFacingDirection.FORWARD
        ));
        imu.initialize(parameters);
        
        // --- SERVO & TIMERS ---
        BallDrop.setPosition(0.2);
        ElapsedTime ballDropTimer = new ElapsedTime();

        telemetry.update();
        waitForStart();

        while (opModeIsActive()) {

            // --- GAMEPAD INPUTS ---
            // Grab base inputs. These will be overridden below if Auto-Aim or Auto-Turn is active.
            double y = -gamepad1.left_stick_y; 
            double x = gamepad1.left_stick_x;  
            double rx = gamepad1.right_stick_x; 

            // --- AUTO AIM LOGIC (LEFT BUMPER) ---
if (gamepad1.left_bumper) {
    // 1. If this is the exact moment the button was pressed, reset the PID math!
    if (!wasLeftBumperPressed) {
        vIntegralSum = 0;
        vLastError = 0;
        vPidTimer.reset();
    }
    wasLeftBumperPressed = true; // Mark that the button is currently being held

    HuskyLens.Block[] blocks = huskyLens.blocks();
    telemetry.addData("Block Count", blocks.length);

    HuskyLens.Block targetTag = null;
    for (HuskyLens.Block block : blocks) {
        if (block.id == 4 || block.id == 1) {
            targetTag = block;
            break;
        }
    }

    if (targetTag != null) {
        // Calculate error (Center of HuskyLens screen is usually 160)
        double error = 160 - targetTag.x; // Flapped so negative/positive match your bot's rotation

        // --- VISION PID MATH ---
        double dt = vPidTimer.seconds();
        if (dt == 0) dt = 0.001; // Prevent dividing by zero

        // Calculate Integral & Derivative
        vIntegralSum += error * dt;
        double derivative = (error - vLastError) / dt;

        // Combine P, I, and D!
        double pidOutput = (vKp * error) + (vKi * vIntegralSum) + (vKd * derivative);
        
        // Apply power (Clipping at 0.4 so it's snappy but safely capped)
        rx = Range.clip(pidOutput, -0.4, 0.4);

        // Update tracking variables for the next loop
        vLastError = error;
        vPidTimer.reset();

        telemetry.addData("Target", "FOUND Tag:ID" + targetTag.id);
        telemetry.addData("Calculated rx", rx);
    } else {
        telemetry.addData("Target", "Searching... (No tag:ID 4 or 1 seen)");
    }
} else {
    // 2. Reset the bumper toggle when the driver lets go
    wasLeftBumperPressed = false; 
}
            // --- HEADING RESET (A BUTTON) ---
            if (gamepad1.a) {
                imu.resetYaw();
                targetHeading = 0;
            }
            
            // --- HEADING CONTROL (D-PAD SNAP) ---
            // 1. Check for D-pad presses to START an auto-turn
            // 1. Check for D-pad presses to START an auto-turn
if (gamepad1.dpad_left) {
    targetHeading = 45;
    isAutoTurning = true;
    
    // Reset PID variables for a fresh turn
    integralSum = 0;
    lastError = 0;
    pidTimer.reset();
} else if (gamepad1.dpad_right) {
    targetHeading = 135;
    isAutoTurning = true;
    
    // Reset PID variables for a fresh turn
    integralSum = 0;
    lastError = 0;
    pidTimer.reset();
}
            // 2. Allow the driver to CANCEL auto-turn by touching the right joystick
          // 3. Execute the turn
if (isAutoTurning) {
    double currentHeading = imu.getRobotYawPitchRollAngles().getYaw(AngleUnit.DEGREES);
    double headingError = targetHeading - currentHeading;

    // Normalize angle to find the shortest path
    while (headingError > 180) headingError -= 360;
    while (headingError < -180) headingError += 360;

    // 4. Check if we are close enough to the target
    if (Math.abs(headingError) < 1.0) { // Tightened deadzone to 1 degree!
        isAutoTurning = false; 
        rx = 0;
    } else {
        // --- PID MATH ---
        // Get how much time has passed since the last loop
        double dt = pidTimer.seconds();
        if (dt == 0) dt = 0.001; // Prevent dividing by zero on the exact first loop

        // Calculate Integral (Sum of past errors)
        integralSum += headingError * dt;

        // Calculate Derivative (Rate of change in error)
        double derivative = (headingError - lastError) / dt;

        // Combine P, I, and D!
        double pidOutput = (Kp * headingError) + (Ki * integralSum) + (Kd * derivative);
        
        // Apply power
        rx = -Range.clip(pidOutput, -1.0, 1.0);

        // Update tracking variables for the next loop
        lastError = headingError;
        pidTimer.reset();
    }
}
            // --- SPINNERS ---
            if (gamepad2.right_bumper) {
                LeftSpinner.setVelocity(1800);
                RightSpinner.setVelocity(1800);
            } else {
                LeftSpinner.setVelocity(0);
                RightSpinner.setVelocity(0);
            }
            
            // --- BALL DROP LOGIC ---
            boolean yPressed = gamepad2.y;
            if (yPressed && !previousYPressed && !isDropping && Math.abs(RightSpinner.getVelocity()) >= 1700) {
                isDropping = true;
                ballDropTimer.reset();
                BallDrop.setPosition(0.0); // Open
                telemetry.addData("ACTION", "Ball Drop OPENED");
            }
            previousYPressed = yPressed;
            
            if (isDropping && ballDropTimer.seconds() >= 0.2 && ballDropTimer.seconds() < 0.3) {
                telemetry.addData("ACTION", "Ball Drop CLOSING");
                BallDrop.setPosition(0.2); // Closed
            }
            
            if (isDropping && ballDropTimer.seconds() >= 0.3) {
                isDropping = false;
                telemetry.addData("ACTION", "Ball Drop CLOSED");
            }
            
            // --- TELEMETRY ---
            // Debug telemetry
            telemetry.addData("Y Pressed", gamepad2.y);
            telemetry.addData("Is Dropping", isDropping);
            telemetry.addData("RightSpinner Velocity", Math.abs(RightSpinner.getVelocity()));
             telemetry.addData("LefttSpinner Velocity", Math.abs(LeftSpinner.getVelocity()));
            telemetry.addData("Ball Drop Timer", ballDropTimer.seconds());
            telemetry.addData("Ball Drop Position", BallDrop.getPosition());
            telemetry.addData("FrontLeft Velocity", frontLeftMotor.getVelocity());
            telemetry.addData("BackLeft Velocity", backLeftMotor.getVelocity());
            telemetry.addData("FrontRight Velocity", frontRightMotor.getVelocity());
            telemetry.addData("BackRight Velocity", backRightMotor.getVelocity());
            telemetry.addData("Heading", imu.getRobotYawPitchRollAngles().getYaw(AngleUnit.DEGREES));


            // --- FIELD CENTRIC DRIVE ---
            // Get the current heading in radians for the math to work properly
            double botHeading = imu.getRobotYawPitchRollAngles().getYaw(AngleUnit.RADIANS);
            
            // Rotate the movement direction counter to the bot's rotation
            double rotX = x * Math.cos(-botHeading) - y * Math.sin(-botHeading);
            double rotY = x * Math.sin(-botHeading) + y * Math.cos(-botHeading);

            rotX = rotX * 1.1;  // Counteract imperfect strafing

            // Denominator is the largest motor power (absolute value) or 1
            double denominator = Math.max(Math.abs(rotY) + Math.abs(rotX) + Math.abs(rx), 1.0);
            double frontLeftPower = (rotY + rotX + rx) / denominator;
            double backLeftPower = (rotY - rotX + rx) / denominator;
            double frontRightPower = (rotY - rotX - rx) / denominator;
            double backRightPower = (rotY + rotX - rx) / denominator;

            frontLeftMotor.setPower(frontLeftPower);
            backLeftMotor.setPower(backLeftPower);
            frontRightMotor.setPower(frontRightPower);
            backRightMotor.setPower(backRightPower);

            telemetry.update();
        }
    }
}